[{"title":"Flag","type":0,"sectionRef":"#","url":"/feature-flags/api/Flag","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#properties","content":" "},{"title":"name​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#name","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; Flag.name: string The name of this flag. "},{"title":"Functions​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#functions","content":" "},{"title":"create​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#create","content":"&lt;/&gt; Flag.create(config: PartialFlagConfig) → () Creates a new flag with the provided configuration. caution Receiving a Flag object generally indicates that a flag already exists. Thecreate function should only be used to create flags that don't already exist. See: create "},{"title":"Errors","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag##","content":"Type\tDescription&quot;Flag '%s' already exists.&quot;\tThrown when a flag with this name already exists.  "},{"title":"exists​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#exists","content":"&lt;/&gt; Flag.exists() → boolean Checks if this flag currently exists. See: exists  "},{"title":"read​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#read","content":"&lt;/&gt; Flag.read() → FlagConfig Reads the data of this flag. See: read  "},{"title":"update​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#update","content":"&lt;/&gt; Flag.update(config: PartialFlagConfig) → () Updates the configuration of this flag. See: update  "},{"title":"retire​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#retire","content":"&lt;/&gt; Flag.retire(retired?: boolean) → () Sets the retired status of this flag. See: retire  "},{"title":"destroy​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#destroy","content":"&lt;/&gt; Flag.destroy() → () Removes this flag entirely. See: destroy  "},{"title":"isActive​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#isActive","content":"&lt;/&gt; Flag.isActive( context?: ActivationContext, config?: ActivationConfig ) → boolean Checks if a feature flag is active based on provided context and configuration. See: isActive  "},{"title":"onChange​","type":1,"pageTitle":"Flag","url":"/feature-flags/api/Flag#onChange","content":"&lt;/&gt; Flag.onChange(callback: (record: ChangeRecord) → ()) → Connection Subscribe to the changed event for this flag. This callback is only invoked when this flag is changed. See: Changed "},{"title":"Client-Server Communication","type":0,"sectionRef":"#","url":"/feature-flags/docs/guides/client-server","content":"","keywords":""},{"title":"Step 1: Decide What Needs Communication​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#step-1-decide-what-needs-communication","content":"Not all flags should be sent to the client. Server-Only Flags: These flags are only relevant to server operations.Sensitive Flags: If a flag contains configurations or data that shouldn't be publicly accessible, keep it on the server. "},{"title":"Rationale​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#rationale","content":"Why doesn't the library handle this for you? Flexibility: Not all feature flags are meant for client-side visibility. Some may be server-side only, while others are crucial for client operations. By not automatically sending all flags to the client, we give developers the discretion to choose which flags to transmit.Data Privacy: Not every flag should be visible to the client, especially if it contains sensitive information or configurations.Efficiency: Automatically sending all flags can be a waste of bandwidth and resources, especially if many flags are not pertinent to the client. "},{"title":"Step 2: Use the Changed Event​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#step-2-use-the-changed-event","content":"Efficiently listen to flag changes with the Changed event. Whenever a feature flag is updated, the library emits a Changed event. Attach a listener to this event to detect and manage updates efficiently. FeatureFlags.Changed:Connect(function(name, record) -- Handle the flag change here end)  "},{"title":"Step 3: Choose a Communication Method​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#step-3-choose-a-communication-method","content":"Consider your game's needs and the number of flags when choosing a method. We recommend the Remote Events method for its clarity and straightforward implementation. "},{"title":"Method A: Using Remote Events (Recommended)​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#method-a-using-remote-events-recommended","content":"Perfect for dynamic datasets and games with a larger number of flags. First, we need to transmit flags to the client. transmitFlags.server.lua local Players = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local FlagEvent = Instance.new(&quot;RemoteEvent&quot;) FlagEvent.Name = &quot;FlagEvent&quot; FlagEvent.Parent = ReplicatedStorage -- Transmit flag changes to the client FeatureFlags.Changed:Connect(function(name, record) FlagEvent:FireAllClients(name, record.new) end) -- Transmit existing flags to the client Players.PlayerAdded:Connect(function(player) for name, flag in FeatureFlags.getAllFlags() do FlagEvent:FireClient(player, name, flag) end end)  Then, we find the event on the client and receive the flag changes. receiveFlags.client.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local FlagEvent = ReplicatedStorage:WaitForChild(&quot;FlagEvent&quot;) -- Listen for flag events FlagEvent.OnClientEvent:Connect(function(name, data) if data then if FeatureFlags.exists(name) then FeatureFlags.update(name, data) else FeatureFlags.create(name, data) end else FeatureFlags.delete(name) end end)  "},{"title":"Method B: Transmitting Flags as Attributes (Alternative)​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#method-b-transmitting-flags-as-attributes-alternative","content":"This method can be useful in certain scenarios but comes with added intricacies. Ensure you understand its workings fully before adopting. First, we create our attribute serialization logic. Serialize.lua local HttpService = game:GetService(&quot;HttpService&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) local Prefix = &quot;flag&quot; local PrefixFormat = string.format(&quot;%s_%s&quot;, Prefix, &quot;%s&quot;) -- Serialize and write a flag to the Workspace local function writeFlag(name, flag) Workspace:SetAttribute(string.format(PrefixFormat, name), HttpService:JSONEncode(flag)) end -- Read and deserialize flag data local function readFlag(flagData) return HttpService:JSONDecode(flagData) end -- Read and deserialize a flag from the Workspace local function readFlagByName(name) return readFlag(Workspace:GetAttribute(string.format(PrefixFormat, name))) end return { Prefix = Prefix, PrefixFormat = PrefixFormat, writeFlag = writeFlag, readFlag = readFlag, readFlagByName = readFlagByName, }  Next, we need to transmit flags to the client using the serialization we wrote. transmitFlags.server.lua local Serialize = require(script.Parent.Serialize) -- Transmit flag changes to the client FeatureFlags.Changed:Connect(function(name, record) Serialize.writeFlag(name, record.new) end) -- Transmit existing flags to the client for name, flag in FeatureFlags.getAllFlags() do Serialize.writeFlag(name, flag) end  Finally, we receive flags on the client using our serialization. receiveFlags.client.lua local Workspace = game:GetService(&quot;Workspace&quot;) local Serialize = require(script.Parent.Serialize) -- Handle any attributes local function handleAttribute(name, value) local prefix, key = string.match(name, &quot;^([^_]+)_(.+)$&quot;) if prefix == Serialize.Prefix then -- Receive flag changes local flagName = key if value then local flag = Serialize.read(value) if FeatureFlags.exists(flagName) then FeatureFlags.update(flagName, flag) else FeatureFlags.create(flagName, flag) end else FeatureFlags.delete(flagName) end elseif ... then -- Handle other unrelated attribute changes end end -- Listen for attribute changes Workspace.AttributeChanged:Connect(function(name) handleAttribute(name, Workspace:GetAttribute(name)) end) -- Receive existing attributes for name, value in Workspace:GetAttributes() do handleAttribute(name, value) end  "},{"title":"Step 4: Handling Activation Functions​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#step-4-handling-activation-functions","content":"Always ensure the client is aware of how to handle activation functions, as these can't be directly serialized. If your flags contain activation functions, they need special treatment. Consider sending a signal or a specific data structure to inform the client when they need to execute a specific predefined function. "},{"title":"How to Pass Activation Functions​","type":1,"pageTitle":"Client-Server Communication","url":"/feature-flags/docs/guides/client-server#how-to-pass-activation-functions","content":"The key challenge with activation functions is that they aren't directly serializable. However, a viable approach involves the use of a reference system. Rather than passing the function, you pass an identifier for the function. The client-side should have a corresponding set of functions to match these identifiers. First, we need a shared module defining the activation functions. ActivationFunctions.lua -- Require all necessary activation functions ... -- Define a dictionary of function identifiers to functions local activationFunctions = { increasedSpeed = increasedSpeed, networkCheck = networkCheck, } -- Define the inverse lookup table local activationFunctionsInverse = {} for name, value in activationFunctions do activationFunctionsInverse[value] = name end return { ToFunction = activationFunctions, ToIdentifier = activationFunctionsInverse, }  Then, we can use this when we transmit our flags. transmitFlags.server.lua -- All previous imports local ActivationFunctions = require(ReplicatedStorage.ActivationFunctions) -- Snip FeatureFlags.Changed:Connect(function(name, record) local transmissionRecord = clone(record.new) -- Convert the activation functions to identifiers for _, ruleSet in transmissionRecord.ruleSets do if ruleSet.activation then ruleSet.activation = ActivationFunctions.ToIdentifier[ruleSet.activation] end end FlagEvent:FireAllClients(name, transmissionRecord) end) -- Snip  And also when we receive our flags. receiveFlags.client.lua -- All previous imports local ActivationFunctions = require(ReplicatedStorage.ActivationFunctions) -- Snip FlagEvent.OnClientEvent:Connect(function(name, data) if data then -- Convert the activation identifiers into functions for _, ruleSet in data.ruleSets do if ruleSet.activation then ruleSet.activation = ActivationFunctions.ToFunction[ruleSet.activation] end end -- Snip end end)  "},{"title":"FeatureFlags","type":0,"sectionRef":"#","url":"/feature-flags/api/FeatureFlags","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#types","content":" "},{"title":"ActivationContext​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#ActivationContext","content":"&lt;/&gt; interface ActivationContext { userId: number?-- The ID of the user groups: {[string]: true}?-- A set of groups systemStates: {[string]: true}?-- A set of system states abSegments: {[string]: true}?-- A set of AB segments } The ActivationContext for a feature' activation. Represents user ID, groups, system states, and AB segments that inform feature activation. These parameters allow features to operate under different rules based on their specific context. For instance, features may activate for specific user groups, AB segments, or under certain system states. Default behavior is applied if a context parameter is not provided. local userContext = { userId = 12345, -- Replace with actual user ID groups = { betaTesters = true }, -- User is in the 'betaTesters' group systemStates = { lowLoad = true }, -- System is currently under low load abSegments = { testA = true }, -- User is in the 'testA' AB segment } if isActive(&quot;ourFeature&quot;, userContext) then -- Our feature is active for this particular context end   "},{"title":"ActivationConfig​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#ActivationConfig","content":"&lt;/&gt; interface ActivationConfig { default: boolean?-- Default activation status if the feature doesn't exist allowRetire: boolean?-- Flag to allow retirement of the feature; if not set and the flag is retired, this notifies in the console warnExists: boolean?-- Flag to warn rather than error when a feature doesn't exist warnRetire: boolean?-- Flag to warn rather than error when a feature is retired } The configuration parameters for a feature's activation. This determines the default state and warning behavior of a feature. This can assist with development of features behind flags, such as throwing errors when flags are being used that are no longer meant to be used. if isActive(&quot;newUI&quot;, userContext, { default = true, -- Assume the feature is active if not found (do not notify) allowRetire = false, -- Notify if the flag has been retired warnRetire = false, -- Error if the flag is retired }) then -- Load the new user interface else -- Load the old user interface end   "},{"title":"InitializationOptions​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#InitializationOptions","content":"&lt;/&gt; interface InitializationOptions { store?: DataStore -- The name of the DataStore to use for serialization synchronizationInterval?: number-- The interval in seconds to synchronize flags } Options to initialize the serialization process with.  "},{"title":"RuleSet​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#RuleSet","content":"&lt;/&gt; interface RuleSet { activation?: (( context?: {[unknown]: unknown}, ruleSet?: {[unknown]: unknown} ) → boolean)-- A custom activation function to evaluate allowedUsers?: {[number]: true}-- A set of user IDs that must match forbiddenUsers?: {[number]: true}-- A set of user IDs that may not match allowedGroups?: {[string]: true}-- A set of groups that must match forbiddenGroups?: {[string]: true}-- A set of groups that may not much allowedSystemStates?: {[string]: true}-- A set of system states that must match forbiddenSystemStates?: {[string]: true}-- A set of system states that may not match abSegments?: {[string]: number}-- A map of AB testing segments } A rule set to determine if a feature should be active for a given context. When a rule set is evaluated against a context, all parts of the rule set must be true for this rule set to pass. If no rule sets match then this rule set will not apply. See isActive for a more detailed explanation. AB testing segments are provided as a map of segment names to segment proportions. All testing segment proportions are added together when selecting a segment to determine the total proportion rather than using a percentage. This enables more specific and configurable group proportions than strict percentages may allow. create(&quot;abTestFlag&quot;, { active: true, ruleSets: { { -- Our AB testing rule set abSegments = { -- Our total proportion is 8, so we're selecting out of 8 total. segment1 = 5, -- This segment accounts for 5/8ths of the population. segment2 = 2, -- This segment accounts for 2/8ths, or 1/4th. segment3 = 1, -- This segment accounts for 1/8th. }, }, }, }) Most rules accept a boolean value for each member. This creates a set of members, but also allows for these to be defined as predicates. Predicates are functions that accept some semantic context and return a boolean value. This allows for more complex contexts to be provided without needing to create specialized logic for each case. local userId = 1234567890 isActive(&quot;predicateFlag&quot;, { userId = userId, groups = { beta = isBetaMember(userId), campaign = isCampaignMember(userId), criticalGeoRegion = isCriticalGeoRegion(userId), }, }) tip Prefer using predicates over activation functions. Predicates are easier to use and understand. The predicate logic is clear to the developer placing a feature behind a flag, and the predicate logic is clear to the developer configuring the flag. Activation functions are less clear and can introduce magic behavior. While the activation function may be clear to the developer configuring the flag, it may not be clear to the developer placing a feature behind a flag, and may even be confusing. Activation functions should be used sparingly and only when predicates are insufficient.  "},{"title":"FlagConfig​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#FlagConfig","content":"&lt;/&gt; interface FlagConfig { active: boolean-- Whether the flag is active retired: boolean-- Whether this flag is retired ruleSets: {RuleSet}-- Rule sets to evaluate for this configuration } The configuration of a flag. Rule sets will be evaluated one at a time to determine if an activation context should have this feature active. See isActive for a more detailed explanation. info The active property controls whether this flag can be active for anyone. If this is false, no one will have this feature active. If a flag should be active in some circumstances, use rule sets.  "},{"title":"PartialFlagConfig​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#PartialFlagConfig","content":"&lt;/&gt; interface PartialFlagConfig { active?: boolean-- Whether the flag is active retired?: boolean-- Whether this flag is retired ruleSets?: {RuleSet}-- Rule sets to evaluate for this configuration } A partial flag configuration. This is used to update a flag. Any properties that are nil will not be updated.  "},{"title":"ChangeRecord​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#ChangeRecord","content":"&lt;/&gt; interface ChangeRecord { old?: FlagConfig-- The old flag, or nil if the flag was just created new?: FlagConfig-- The new flag, or nil if the flag no longer exists } A record of how a flag has changed.  "},{"title":"UpdateOptions​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#UpdateOptions","content":"&lt;/&gt; interface UpdateOptions { serialize: boolean-- Whether this change should be serialized } Options for updating a flag. These are options for how a flag should be updated. Here you can specify whether this change should be serialized. The default is false.  "},{"title":"PartialUpdateOptions​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#PartialUpdateOptions","content":"&lt;/&gt; interface PartialUpdateOptions { serialize?: boolean-- Whether this change should be serialized } Partial update options. This is used to configure a flag update. Any properties that are nil will be given default values. "},{"title":"Properties​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#properties","content":" "},{"title":"Changed​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#Changed","content":"&lt;/&gt; FeatureFlags.Changed: Event The flag changed event. This fires every time a flag changes. It provides the name, a ChangeRecord, and UpdateOptions. Changed:Connect(function(name: string, record: ChangeRecord, options: UpdateOptions) print(string.format(&quot;Flag '%s' changed.&quot;, name)) print(&quot;Old flag:&quot;, record.old) print(&quot;New flag:&quot;, record.new) if options.serialize then print(&quot;This change will be serialized.&quot;) end end)  "},{"title":"Functions​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#functions","content":" "},{"title":"isActive​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#isActive","content":"&lt;/&gt; FeatureFlags.isActive( name: string,-- The name of the feature flag to check context?: ActivationContext,-- The user context for this feature activation config?: ActivationConfig-- The configuration parameters for this feature activation ) → boolean-- Whether the feature should be active Checks if a feature flag is active based on provided context and configuration. The isActive function evaluates whether a feature should be active based on the provided user context and configuration. It normalizes these inputs, using default values for any missing context or configuration properties. if isActive(&quot;uiUpdate&quot;, { userId = 1000, groups = { beta = true }, abSegments = { newInventory = true }, }) then -- The user with this context should have this feature active. end The feature flag's existence and retirement status are then checked: If the feature doesn't exist, the behavior depends on the warnExists and default configuration properties. If warnExists is true, a warning is logged. If default is provided, the default value is returned. If neither a warning is logged nor a default value is provided, an error is thrown. If nothing else causes the function to terminate a default value of false is returned. if isActive(&quot;missingFlag&quot;, activationContext, { default = true, warnExists = true, }) then -- If the flag no longer exists we still execute this code. -- A warning is logged rather than an error. else -- The flag exists, but is set to false. end If the feature is retired, the behavior depends on the allowRetire and warnRetire configuration properties. If allowRetire is false, an error is thrown. If allowRetire is true but warnRetire is true as well, a warning is logged. if isActive(&quot;oldFlag&quot;, activationContext, { allowRetire = true, warnRetire = true, }) then -- A retired flag can still be checked, but a warning is logged. end The flag's active status is then checked. If the flag isn't active, then false is returned immediately. info An inactive flag indicates it should not be active for anyone or under any circumstances. To activate a feature conditionally rule sets should be used. If the flag is active, each rule set in the feature flag's configuration is evaluated using the provided context: If a rule set evaluates to true, the feature is active. If no rule set evaluates to true, but at least one rule set was evaluated (i.e., it matched the context even though it evaluated to false), the feature is not active. If no rule set matches the context (i.e., none of the rule sets were evaluated), this means that no rules apply to disable a feature for the provided context. The feature is considered active. caution This is sometimes unintuitive for users unfamiliar with it. Consider the case where a rule set to activate a feature for a specific user ID is configured but the feature is being activated without a user context, such as on the server. In such a case, the user restriction should not be considered matching and the feature should be considered active if no other rules apply.   "},{"title":"init​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#init","content":"&lt;/&gt; FeatureFlags.init( options?: InitializationOptions-- Options to initialize the serialization process ) → Connection-- A connection that can be used to disconnect the serialization process Initializes the serialization process. Begins synchronizing flags with the data store. This will listen for local changes to flags that are marked for serialization and update the data store accordingly. Local changes are listened for continuously, but only sent to the data store in specified intervals to help avoid rate limits. info This should be started as soon as possible in a game's lifecycle to ensure that flags are synchronized as soon as possible. Any features that depend on serialized flags will be unavailable until this is started and synchronized. init({ store = &quot;MyFeatureFlagStore&quot;, synchronizationInterval = 300, -- 5 minutes }) The initial synchronization happens immediately as this is called. This ensures that flags are available as soon as possible. Later synchronizations will happen in the specified interval. Flag changes can easily be marked for serialization by updating them while passing the serialize option of UpdateOptions. This will mark the flag as needing serialization and will be synchronized with the data store during the next synchronization interval. -- This flag will not be serialized update(&quot;localFlag&quot;, { -- Desired flag changes }) -- Mark this flag for serialization update(&quot;serializedFlag&quot;, { -- Desired flag changes }, { serialize = true, }) This is a convenience function that takes care of gathering flag changes and synchronizing them with a data store. If you need more control over the serialization process, you can create your own bespoke serialization process instead using the Changed event and the serialize option of UpdateOptions.  "},{"title":"create​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#create","content":"&lt;/&gt; FeatureFlags.create( name: string,-- The name to use for the flag config: PartialFlagConfig?,-- The configuration of this flag options: PartialUpdateOptions? ) → () Creates a new flag with the provided name and configuration. note This only needs to be used when introducing new flags, such as when you want to introduce a new flag for a feature ahead of time. This is typically done through some configuration interface, such as the built in one. tip If updating a flag that already exists, use the update function instead. "},{"title":"Errors","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags##","content":"Type\tDescription&quot;Flag '%s' already exists.&quot;\tThrown when a flag with this name already exists.  "},{"title":"exists​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#exists","content":"&lt;/&gt; FeatureFlags.exists(name: string) → boolean Checks if a flag with this name currently exists.  "},{"title":"read​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#read","content":"&lt;/&gt; FeatureFlags.read(name: string) → FlagConfig Reads the data of this flag. This is primarily useful to display or manipulate flag information. caution This shouldn't be used to determine flag activation. Use the isActive function instead. While this contains all flag information, it doesn't include any complex activation evaluation logic that isActive does. "},{"title":"Errors","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags##","content":"Type\tDescription&quot;Flag '%s' doesn't exist.&quot;\tThrown when a flag with this name doesn't exist.  "},{"title":"update​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#update","content":"&lt;/&gt; FeatureFlags.update( name: string, config: PartialFlagConfig, options: PartialUpdateOptions? ) → () Updates the configuration of this flag. "},{"title":"Errors","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags##","content":"Type\tDescription&quot;Flag '%s' doesn't exist.&quot;\tThrown when a flag with this name doesn't exist.  "},{"title":"retire​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#retire","content":"&lt;/&gt; FeatureFlags.retire( name: string, retired?: boolean,-- The retired status of the flag options: PartialUpdateOptions? ) → () Sets the retired status of a flag. If a retired status isn't provided it defaults to true, assuming you intend to retire a flag. "},{"title":"Errors","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags##","content":"Type\tDescription&quot;Flag '%s' doesn't exist.&quot;\tThrown when a flag with this name doesn't exist.  "},{"title":"destroy​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#destroy","content":"&lt;/&gt; FeatureFlags.destroy( name: string, options: PartialUpdateOptions? ) → () Removes a flag entirely. "},{"title":"Errors","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags##","content":"Type\tDescription&quot;Flag '%s' doesn't exist.&quot;\tThrown when a flag with this name doesn't exist.  "},{"title":"reset​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#reset","content":"&lt;/&gt; FeatureFlags.reset( notify?: boolean-- Whether to notify listeners of this change ) → () Resets all registered flags. After this operation, there will be no registered flags and flags will need to be registered again before they can be used. This is primarily used to re-initialize all feature flags. Notification will inform all listeners about the removal of all flags. Performing no notification is faster, but may break features currently listening. The default is not to notify, assuming that features listening to flags have already been handled or are not currently listening.  "},{"title":"get​","type":1,"pageTitle":"FeatureFlags","url":"/feature-flags/api/FeatureFlags#get","content":"&lt;/&gt; FeatureFlags.get( name: string-- The name of the flag ) → Promise&lt;Flag&gt;-- A Promise of the Flag requested Gets a flag asynchronously. get(&quot;newActivity&quot;):andThen(function(flag: Flag) -- The flag is available to use. if flag.isActive() then -- The flag is active. end end)  "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"/feature-flags/docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"/feature-flags/docs/intro#installation","content":"To use Feature Flags, you need to include it as a dependency in yourwally.toml file. Feature Flags can then be installed with Wally. FeatureFlags = &quot;team-snowdust/feature-flags@0.1.0&quot;  "},{"title":"Usage​","type":1,"pageTitle":"Getting Started","url":"/feature-flags/docs/intro#usage","content":"To place features behind flags in your project, simply require the module and access the flags you want to use and check if they're active. For example, to use the newHeroUpdate flag we can request it asynchronously: local FeatureFlags = require(ReplicatedStorage.Packages.FeatureFlags) -- Asynchronously request our new hero feature flag. FeatureFlags.get(&quot;newHeroUpdate&quot;):andThen(function(flag: FeatureFlags.Flag) -- When the flag exists, check if it's active for the current user context. if flag.isActive({ userId = Players.LocalPlayer.UserId, groups = { beta = isBetaTester(Players.LocalPlayer) }, }) then -- The new hero is active for this user. Show off the new hero. displayNewHeroShowcase() else -- The new hero is not active for this user. Tease the hero that will be -- available soon. displayNewHeroTeaser() end end)  Refer to the API documentation for more detailed information. "}]