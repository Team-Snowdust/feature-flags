"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[483],{62665:e=>{e.exports=JSON.parse('{"functions":[{"name":"get","desc":"Gets a flag asynchronously.\\n\\n```lua\\nget(\\"newActivity\\"):andThen(function(flag: Flag)\\n\\t-- The flag is available to use.\\n\\tif flag.isActive() then\\n\\t\\t-- The flag is active.\\n\\tend\\nend)\\n```","params":[{"name":"name","desc":"The name of the flag","lua_type":"string"}],"returns":[{"desc":"A Promise of the Flag requested","lua_type":"Promise<Flag>"}],"function_type":"static","source":{"line":26,"path":"lib/get.lua"}},{"name":"isActive","desc":"Checks if a feature flag is active based on provided context and\\nconfiguration.\\n\\nThe `isActive` function evaluates whether a feature should be active based on\\nthe provided user context and configuration. It normalizes these inputs, using\\ndefault values for any missing context or configuration properties.\\n\\n```lua\\nif isActive(\\"uiUpdate\\", {\\n\\tuserId = 1000,\\n\\tgroups = { beta = true },\\n\\tabSegments = { newInventory = true },\\n}) then\\n\\t-- The user with this context should have this feature active.\\nend\\n```\\n\\nThe feature flag\'s existence and retirement status are then checked:\\n\\n- If the feature doesn\'t exist, the behavior depends on the `warnExists` and\\n  `default` configuration properties.\\n\\n  1. If `warnExists` is true, a warning is logged.\\n  2. If `default` is provided, the `default` value is returned.\\n  3. If neither a warning is logged nor a `default` value is provided, an\\n     error is thrown.\\n  4. If nothing else causes the function to terminate a default value of false\\n     is returned.\\n\\n  ```lua\\n  if isActive(\\"missingFlag\\", activationContext, {\\n  \\tdefault = true,\\n  \\twarnExists = true,\\n  }) then\\n  \\t-- If the flag no longer exists we still execute this code.\\n  \\t-- A warning is logged rather than an error.\\n  else\\n  \\t-- The flag exists, but is set to false.\\n  end\\n  ```\\n\\n- If the feature is retired, the behavior depends on the `allowRetire` and\\n  `warnRetire` configuration properties.\\n\\n  1. If `allowRetire` is false, an error is thrown.\\n  2. If `allowRetire` is true but `warnRetire` is true as well, a warning is\\n     logged.\\n\\n  ```lua\\n  if isActive(\\"oldFlag\\", activationContext, {\\n  \\tallowRetire = true,\\n  \\twarnRetire = true,\\n  }) then\\n  \\t-- A retired flag can still be checked, but a warning is logged.\\n  end\\n  ```\\n\\nThe flag\'s active status is then checked. If the flag isn\'t active, then false\\nis returned immediately.\\n\\n:::info\\nAn inactive flag indicates it should not be active for anyone or under any\\ncircumstances. To activate a feature conditionally rule sets should be used.\\n:::\\n\\nIf the flag is active, each rule set in the feature flag\'s configuration is\\nevaluated using the provided context:\\n\\n- If a rule set evaluates to true, the feature is active.\\n- If no rule set evaluates to true, but at least one rule set was evaluated\\n  (i.e., it matched the context even though it evaluated to false), the\\n  feature is not active.\\n- If no rule set matches the context (i.e., none of the rule sets were\\n  evaluated), this means that no rules apply to disable a feature for the\\n  provided context. The feature is considered active.\\n\\n\\t:::caution\\n  This is sometimes unintuitive for users unfamiliar with it.\\n\\n  Consider the case where a rule set to activate a feature for a specific user\\n  ID is configured but the feature is being activated without a user context,\\n  such as on the server. In such a case, the user restriction should not be\\n  considered matching and the feature should be considered active if no other\\n  rules apply.\\n\\t:::","params":[{"name":"name","desc":"The name of the feature flag to check","lua_type":"string"},{"name":"context?","desc":"The user context for this feature activation","lua_type":"ActivationContext"},{"name":"config?","desc":"The configuration parameters for this feature activation","lua_type":"ActivationConfig"}],"returns":[{"desc":"Whether the feature should be active","lua_type":"boolean"}],"function_type":"static","source":{"line":383,"path":"lib/isActive.lua"}},{"name":"create","desc":"Creates a new flag with the provided name and configuration.\\n\\n:::note\\nThis only needs to be used when introducing new flags, such as when you want\\nto introduce a new flag for a feature ahead of time.\\n\\nThis is typically done through some configuration interface, such as the built\\nin one.\\n:::\\n\\n:::tip\\nIf updating a flag that already exists, use the `update` function instead.\\n:::","params":[{"name":"name","desc":"The name to use for the flag","lua_type":"string"},{"name":"config","desc":"The configuration of this flag","lua_type":"FlagConfig"},{"name":"retired?","desc":"Whether this flag is retied","lua_type":"boolean"}],"returns":[],"function_type":"static","errors":[{"lua_type":"\\"Flag \'%s\' already exists.\\"","desc":"Thrown when a flag with this name already exists."}],"source":{"line":207,"path":"lib/Flags.lua"}},{"name":"exists","desc":"Checks if a flag with this name currently exists.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"boolean\\n"}],"function_type":"static","source":{"line":223,"path":"lib/Flags.lua"}},{"name":"read","desc":"Reads the data of this flag.\\n\\nThis is primarily useful to display or manipulate flag information.\\n\\n:::caution\\nThis shouldn\'t be used to determine flag activation. Use the `isActive`\\nfunction instead.\\n\\nWhile this contains all flag information, it doesn\'t include any complex\\nactivation evaluation logic that `isActive` does.\\n:::","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"FlagData\\n"}],"function_type":"static","errors":[{"lua_type":"\\"Flag \'%s\' doesn\'t exist.\\"","desc":"Thrown when a flag with this name doesn\'t exist."}],"source":{"line":244,"path":"lib/Flags.lua"}},{"name":"update","desc":"Updates the configuration of this flag.","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"config","desc":"","lua_type":"FlagConfig"}],"returns":[],"function_type":"static","errors":[{"lua_type":"\\"Flag \'%s\' doesn\'t exist.\\"","desc":"Thrown when a flag with this name doesn\'t exist."}],"source":{"line":259,"path":"lib/Flags.lua"}},{"name":"retire","desc":"Sets the retired status of a flag.\\n\\nIf a retired status isn\'t provided it defaults to true, assuming you intend to\\nretire a flag.","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"retired?","desc":"The retired status of the flag","lua_type":"boolean"}],"returns":[],"function_type":"static","errors":[{"lua_type":"\\"Flag \'%s\' doesn\'t exist.\\"","desc":"Thrown when a flag with this name doesn\'t exist."}],"source":{"line":279,"path":"lib/Flags.lua"}},{"name":"destroy","desc":"Removes a flag entirely.","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[],"function_type":"static","errors":[{"lua_type":"\\"Flag \'%s\' doesn\'t exist.\\"","desc":"Thrown when a flag with this name doesn\'t exist."}],"source":{"line":295,"path":"lib/Flags.lua"}},{"name":"reset","desc":"Resets all registered flags.\\n\\nAfter this operation, there will be no registered flags and flags will need to\\nbe registered again before they can be used. This is primarily used to\\nre-initialize all feature flags.\\n\\nNotification will inform all listeners about the removal of all flags.\\nPerforming no notification is faster, but may break features currently\\nlistening. The default is not to notify, assuming that features listening to\\nflags have already been handled or are not currently listening.","params":[{"name":"notify?","desc":"Whether to notify listeners of this change","lua_type":"boolean"}],"returns":[],"function_type":"static","source":{"line":318,"path":"lib/Flags.lua"}}],"properties":[{"name":"Changed","desc":"The flag changed event.\\n\\nThis fires every time a flag changes. It provides the name and a\\n[ChangeRecord].\\n\\n```lua\\nChanged:Connect(function(name: string, record: ChangeRecord)\\n\\tprint(string.format(\\"Flag \'%s\' changed.\\", name))\\n\\tprint(\\"Old flag:\\", record.old)\\n\\tprint(\\"New flag:\\", record.new)\\nend)\\n```","lua_type":"Event","source":{"line":138,"path":"lib/Flags.lua"}}],"types":[{"name":"ActivationContext","desc":"The ActivationContext for a feature\' activation.\\n\\nRepresents user ID, groups, system states, and AB segments that inform feature\\nactivation. These parameters allow features to operate under different rules\\nbased on their specific context.\\n\\nFor instance, features may activate for specific user groups, AB segments, or\\nunder certain system states.\\n\\nDefault behavior is applied if a context parameter is not provided.\\n\\n```lua\\nlocal userContext = {\\n\\tuserId = 12345, -- Replace with actual user ID\\n\\tgroups = { betaTesters = true }, -- User is in the \'betaTesters\' group\\n\\tsystemStates = { lowLoad = true }, -- System is currently under low load\\n\\tabSegments = { testA = true }, -- User is in the \'testA\' AB segment\\n}\\n\\nif isActive(\\"ourFeature\\", userContext) then\\n\\t-- Our feature is active for this particular context\\nend\\n```","fields":[{"name":"userId","lua_type":"number?","desc":"The ID of the user"},{"name":"groups","lua_type":"{ [string]: true }?","desc":"A set of groups"},{"name":"systemStates","lua_type":"{ [string]: true }?","desc":"A set of system states"},{"name":"abSegments","lua_type":"{ [string]: true }?","desc":"A set of AB segments"}],"source":{"line":45,"path":"lib/isActive.lua"}},{"name":"ActivationConfig","desc":"The configuration parameters for a feature\'s activation.\\n\\nThis determines the default state and warning behavior of a feature. This can\\nassist with development of features behind flags, such as throwing errors when\\nflags are being used that are no longer meant to be used.\\n\\n```lua\\nif\\n\\tisActive(\\"newUI\\", userContext, {\\n\\t\\tdefault = true, -- Assume the feature is active if not found (do not notify)\\n\\t\\tallowRetire = false, -- Notify if the flag has been retired\\n\\t\\twarnRetire = false, -- Error if the flag is retired\\n\\t})\\nthen\\n\\t-- Load the new user interface\\nelse\\n\\t-- Load the old user interface\\nend\\n```","fields":[{"name":"default","lua_type":"boolean?","desc":"Default activation status if the feature doesn\'t exist"},{"name":"allowRetire","lua_type":"boolean?","desc":"Flag to allow retirement of the feature; if not set and the flag is retired, this notifies in the console"},{"name":"warnExists","lua_type":"boolean?","desc":"Flag to warn rather than error when a feature doesn\'t exist"},{"name":"warnRetire","lua_type":"boolean?","desc":"Flag to warn rather than error when a feature is retired"}],"source":{"line":81,"path":"lib/isActive.lua"}},{"name":"RuleSet","desc":"A rule set to determine if a feature should be active for a given context.\\n\\nWhen a rule set is evaluated against a context, all parts of the rule set must\\nbe true for this rule set to pass. If no rule sets match then this rule set\\nwill not apply. See [isActive](#isActive) for a more detailed explanation.\\n\\nAB testing segments are provided as a map of segment names to segment\\nproportions. All testing segment proportions are added together when selecting\\na segment to determine the total proportion rather than using a percentage.\\nThis enables more specific and configurable group proportions than strict\\npercentages may allow.\\n\\n```lua\\ncreate(\\"abTestFlag\\", {\\n\\tactive: true,\\n\\truleSets: {\\n\\t\\t{ -- Our AB testing rule set\\n\\t\\t\\tabSegments = {\\n\\t\\t\\t\\t-- Our total proportion is 8, so we\'re selecting out of 8 total.\\n\\t\\t\\t\\tsegment1 = 5, -- This segment accounts for 5/8ths of the population.\\n\\t\\t\\t\\tsegment2 = 2, -- This segment accounts for 2/8ths, or 1/4th.\\n\\t\\t\\t\\tsegment3 = 1, -- This segment accounts for 1/8th.\\n\\t\\t\\t},\\n\\t\\t},\\n\\t},\\n})\\n```","fields":[{"name":"activation?","lua_type":"((context?: { [unknown]: unknown }, ruleSet?: { [unknown]: unknown }) -> boolean)","desc":"A custom activation function to evaluate"},{"name":"allowedUsers?","lua_type":"{ [number]: true }","desc":"A set of user IDs that must match"},{"name":"forbiddenUsers?","lua_type":"{ [number]: true }","desc":"A set of user IDs that may not match"},{"name":"allowedGroups?","lua_type":"{ [string]: true }","desc":"A set of groups that must match"},{"name":"forbiddenGroups?","lua_type":"{ [string]: true }","desc":"A set of groups that may not much"},{"name":"allowedSystemStates?","lua_type":"{ [string]: true }","desc":"A set of system states that must match"},{"name":"forbiddenSystemStates?","lua_type":"{ [string]: true }","desc":"A set of system states that may not match"},{"name":"abSegments?","lua_type":"{ [string]: number }","desc":"A map of AB testing segments"}],"source":{"line":45,"path":"lib/Flags.lua"}},{"name":"FlagConfig","desc":"The configuration of a flag.\\n\\nRule sets will be evaluated one at a time to determine if an activation\\ncontext should have this feature active. See [isActive](#isActive) for a more\\ndetailed explanation.\\n\\nThe configuration additionally includes all [RuleSet] properties and can be\\nused as a primary rule set. This rule set, when used this way, is guaranteed\\nto be evaluated first. This is useful if there is a common rule set that is\\nmore important, is a hot path, or if there is only one rule set.\\n\\n:::info\\nThe active property controls whether this flag can be active for anyone. If\\nthis is false, no one will have this feature active. If a flag should be\\nactive in some circumstances, use rule sets.\\n:::","fields":[{"name":"active","lua_type":"boolean","desc":"Whether the flag is active"},{"name":"ruleSets?","lua_type":"{ RuleSet }","desc":"Rule sets to evaluate for this configuration"}],"source":{"line":80,"path":"lib/Flags.lua"}},{"name":"FlagData","desc":"All data associated with a flag.","fields":[{"name":"config","lua_type":"FlagConfig","desc":"The configuration for this flag"},{"name":"retired","lua_type":"boolean","desc":"Whether this flag is retired"}],"source":{"line":94,"path":"lib/Flags.lua"}},{"name":"ChangeRecord","desc":"A record of how a flag has changed.","fields":[{"name":"old?","lua_type":"FlagData","desc":"The old flag, or nil if the flag was just created"},{"name":"new?","lua_type":"FlagData","desc":"The new flag, or nil if the flag no longer exists"}],"source":{"line":108,"path":"lib/Flags.lua"}}],"name":"FeatureFlags","desc":"","source":{"line":8,"path":"lib/init.lua"}}')}}]);